#simulation of binomials to asses normality
# Define starting assumptions and conditions ----
# hypotheses:
# H0: p = p0
# H1: p > p0
n_studies <- seq(5,1000)
n_sim <- 5e3
alpha <- 0.001
p1s <- seq(0.01,0.99,by=0.01)

# Define vst and helper functions  ----
vst <- function(p0,p1,n){
  Tn <- 2*sqrt(n)*(asin(sqrt(p1))-asin(sqrt(p0)))
  return(Tn)
}

#z-statistic based on CLT
clt <- function(p0,p1,n){
  Tn <- (p1-p0)/sqrt(p1*(1-p1)/n)
  return(Tn)
}

rss_calculator <- function(x,y,avg=T){
  if (avg==T){
    rss <- sum((x-y)^2)/length(n)
  } else {
    rss <- sum((x-y)^2) 
  }
  return(rss)
}



shapiro.test(rbinom(200,100,0.5))

test <- rbinom(n_sim,5,0.5)
test <- test/5

shapiro.test(vst(0,rbinom(n_sim,100,0.5)/100,100))

n_p_mat <- matrix(data=c(n_studies,p1s),ncol=length(p1s),nrow=length(n_studies))

T_vst <- sapply(p1s,function(p1) sapply(n_studies, function(n_study) vst(0,p1,n_study)))
T_clt <- sapply(p1s,function(p1) sapply(n_studies, function(n_study) clt(0,p1,n_study)))

n_sim <- 10000
n <- 1000
p <- 0.5
mu <- p*n
sd <- sqrt(n*p*(1-p))
se <- sqrt(p*(1-p)/n)
probs <- seq(0.01,0.99,length.out=1000)

Q_stdnorm <- qnorm(probs,0,1)
z_bino <- (rbinom(n_sim,n,p)-mu)/n/se
Fz_bino <- ecdf(z_bino)
Qz_bino <- Fz_bino(probs) 
normdist <- rnorm(n_sim,0,1)
Fz_norm <- ecdf(normidst)

  
rss_calculator(ecdf(bino),stdnorm,avg=T)
rss_calculator(ecdf(normdist),stdnorm,avg=T)


